component cablekins "kinematics for a cable driven robot";

description
"""
.if \\n[.g] .mso www.tmac

The userkins.comp file is a template for creating kinematics that can be user-built using halcompile.

The unmodified userkins component can be used as a kinematics file
for a machine with identity kinematics for an xyz machine employing 3 joints (motors).

\\fBUSAGE:\\fR

  1) Copy the userkins.comp file to a user-owned directory (\\fBmydir\\fR).

     Note: The userkins.comp file can be downloaded from:
.URL https://github.com/LinuxCNC/linuxcnc/raw/2.8/src/hal/components/userkins.comp
     where '2.8' is the branch name (use 'master' for the master branch)

     For a RIP (run-in-place) build, the file is located in
     the git tree as:
       src/hal/components/userkins.comp

  2) Edit the functions kinematicsForward() and kinematicsInverse() as required.
  3) If required, add HAL pins following examples in the template code.
  4) Build and install the component using halcompile:
     $ cd \\fBmydir\\fR
     $ [sudo] halcompile --install userkins.comp
     # Note:
     #      sudo is required when using a deb install
     #      sudo is \\fBnot\\fR required for run-in-place builds
     # $ man halcompile for more info
  5) Specify userkins in an ini file as:
     \\fB[KINS]\\fR
     \\fBKINEMATICS=userkins\\fR
     \\fBJOINTS=3\\fR
     # the number of JOINTS must agree with the
     # number of joints used in your modified userkins.comp
  6) Note: the manpage for userkins is not updated by halcompile --install
  7) To use a different component name, rename the file (example mykins.comp)
     and change all instances of 'userkins' to 'mykins'.

\\fBNOTES:\\fR
  1  The \\fBfpin\\fR pin is included to satisfy the requirements of the
     halcompile utility but it is not accessible to kinematics functions.

  2  HAL pins and parameters needed in kinematics functions (kinematicsForward(),
     kinematicsInverse()) must be setup in a function (\\fBuserkins_setup()\\fR)
     invoked by the initial motion module call to kinematicsType().
""";
// The fpin pin is not accessible in kinematics functions.
// Use the *_setup() function for pins and params used by kinematics.


// 2024-08-17 - First shot at forward kinematics using Newton Raphison - dcf

pin out s32 fpin=0"pin to demonstrate use of a conventional (non-kinematics) function fdemo";
function fdemo;
license "GPL";
author "Dave Franchino";
;;

#include "rtapi_math.h"
#include "kinematics.h"

// Constants
#define PI 3.14159265358979323846
#define LEFT_DRUM_X 0.0
#define LEFT_DRUM_Y 0.0
#define RIGHT_DRUM_X 500.0
#define RIGHT_DRUM_Y 0.0
#define DRUM_DIAMETER (360/PI)
#define DRUM_CIRCUMFERENCE 350.0

#define HOME_X 100.0
#define HOME_Y -250.0

#define LEFT_CABLE_HOME_LENGTH 296.237
#define RIGHT_CABLE_HOME_LENGTH 531.375

//subfunctions 

double calcF1(double thetaL, double thetaR) {
  double XL = LEFT_DRUM_X -cos(thetaL) * DRUM_DIAMETER/2 + (LEFT_CABLE_HOME_LENGTH- thetaL * DRUM_DIAMETER/2) * sin(thetaL);
  double XR = RIGHT_DRUM_X + cos(thetaR) * DRUM_DIAMETER/2 - (RIGHT_CABLE_HOME_LENGTH - thetaR * DRUM_DIAMETER/2) * sin(thetaR);
  return XL - XR;
}

double calcF2(float thetaL, float thetaR) {
  double YL = LEFT_DRUM_Y-sin(thetaL) * DRUM_DIAMETER/2 - (LEFT_CABLE_HOME_LENGTH - thetaL * DRUM_DIAMETER/2) * cos(thetaL);
  double YR = RIGHT_DRUM_Y-sin(thetaR) * DRUM_DIAMETER/2 - (RIGHT_CABLE_HOME_LENGTH - thetaR * DRUM_DIAMETER/2) * cos(thetaR);
  return YL - YR;
}


double** calcJacobian(double thetaL, double thetaR) {
    // Allocate memory for the Jacobian matrix
    double** jacobian = hal_malloc(2 * sizeof(double*));
    jacobian[0] = hal_malloc(2 * sizeof(double));
    jacobian[1] = hal_malloc(2 * sizeof(double));

    // Compute the partial derivatives
    double dF1dThetaL = (calcF1(thetaL + 0.0001, thetaR) - calcF1(thetaL, thetaR)) / 0.0001;
    double dF1dThetaR = (calcF1(thetaL, thetaR + 0.0001) - calcF1(thetaL, thetaR)) / 0.0001;
    double dF2dThetaL = (calcF2(thetaL + 0.0001, thetaR) - calcF2(thetaL, thetaR)) / 0.0001;
    double dF2dThetaR = (calcF2(thetaL, thetaR + 0.0001) - calcF2(thetaL, thetaR)) / 0.0001;

    // Assign the computed values to the Jacobian matrix
    jacobian[0][0] = dF1dThetaL;
    jacobian[0][1] = dF1dThetaR;
    jacobian[1][0] = dF2dThetaL;
    jacobian[1][1] = dF2dThetaR;

    // Return the Jacobian matrix
    return jacobian;
}

double** invertMatrix(double** m) {
    // Allocate memory for the inverted matrix
    double** invertedMatrix = hal_malloc(2 * sizeof(double*));
    invertedMatrix[0] = hal_malloc(2 * sizeof(double));
    invertedMatrix[1] = hal_malloc(2 * sizeof(double));

    // Compute the determinant of the 2x2 matrix
    double det = m[0][0] * m[1][1] - m[0][1] * m[1][0];

    // Check if the matrix is invertible
    if (det == 0.0) {
    // Handle the error (e.g., return NULL or an error code)
    // For this example, we'll just return NULL
    return NULL;
    }

    // Calculate the inverse of the matrix
    invertedMatrix[0][0] = m[1][1] / det;
    invertedMatrix[0][1] = -m[0][1] / det;
    invertedMatrix[1][0] = -m[1][0] / det;
    invertedMatrix[1][1] = m[0][0] / det;

    // Return the inverted matrix
    return invertedMatrix;
}


static struct haldata {
  // Example pin pointers
  hal_u32_t *in;
  hal_u32_t *out;
  // Example parameters
  hal_float_t param_rw;
  hal_float_t param_ro;
} *haldata;

FUNCTION(fdemo) {
   // This function can be added to a thread (addf) for
   // purposes not related to the kinematics functions.
   if (fpin == 0) {
       rtapi_print("fdemo function added to thread\n");
   }
   fpin++;
}

static int cablekins_setup(void) {
#define HAL_PREFIX "cablekins"
    int res=0;

    // inherit comp_id from rtapi_main()
    if (comp_id < 0) goto error;
    // set unready to allow creation of pins
    if (hal_set_unready(comp_id)) goto error;

    haldata = hal_malloc(sizeof(struct haldata));
    if (!haldata) goto error;

    // hal pin examples:
    res += hal_pin_u32_newf(HAL_IN ,&(haldata->in) ,comp_id,"%s.in" ,HAL_PREFIX);
    res += hal_pin_u32_newf(HAL_OUT,&(haldata->out),comp_id,"%s.out",HAL_PREFIX);

    // hal parameter examples:
    res += hal_param_float_newf(HAL_RW, &haldata->param_rw,comp_id,"%s.param-rw",HAL_PREFIX);
    res += hal_param_float_newf(HAL_RO, &haldata->param_ro,comp_id,"%s.param-ro",HAL_PREFIX);

    if (res) goto error;
    hal_ready(comp_id);
    rtapi_print("*** %s setup ok\n",__FILE__);
    return 0;
error:
    rtapi_print("\n!!! %s setup failed res=%d\n\n",__FILE__,res);
    return -1;
#undef HAL_PREFIX
}

KINS_NOT_SWITCHABLE
// see millturn.comp for example of switchable kinematics

EXPORT_SYMBOL(kinematicsType);
EXPORT_SYMBOL(kinematicsInverse);
EXPORT_SYMBOL(kinematicsForward);

KINEMATICS_TYPE kinematicsType()
{
static bool is_setup=0;
    if (!is_setup) cablekins_setup();
    return KINEMATICS_IDENTITY; // set as required
       // Note: If kinematics are identity, using KINEMATICS_BOTH
       //       may be used in order to allow a gui to display
       //       joint values in preview prior to homing
} // kinematicsType()

static bool is_ready=0;
int kinematicsForward(const double *j, EmcPose *pos, const KINEMATICS_FORWARD_FLAGS *fflags, KINEMATICS_INVERSE_FLAGS *iflags)
{

	return 0;
    
    double thetaL = 1.0; // initial guess for left drum angle for Newton Raphison 
    double thetaR = 1.0; //

    while (1) {
    double f1 = calcF1(thetaL, thetaR);
    double f2 = calcF2(thetaL, thetaR);

    // Calculate Jacobian matrix
    double** J = calcJacobian(thetaL, thetaR);

    // Calculate inverse of the Jacobian matrix
    double** J_inv = invertMatrix(J);

    // Update thetaL and thetaR
    double deltaThetaL = J_inv[0][0] * f1 + J_inv[0][1] * f2;
    double deltaThetaR = J_inv[1][0] * f1 + J_inv[1][1] * f2;

    thetaL -= deltaThetaL;
    thetaR -= deltaThetaR;
    
    double arcL = thetaL * DRUM_DIAMETER / 2;
    double tangentL = LEFT_CABLE_HOME_LENGTH - arcL;
    double tangentxL = LEFT_DRUM_X - cos(thetaL) * DRUM_DIAMETER / 2;
    double tangentyL = LEFT_DRUM_Y- sin(thetaL) * DRUM_DIAMETER / 2;
    double X = tangentxL + tangentL * sin(thetaL);
    double Y = tangentyL - tangentL * cos(thetaL);

    // Check for convergence
    if (fabs(deltaThetaL) < 0.0001 && fabs(deltaThetaR) < 0.0001) {
            
    	// Store the results in the EmcPose structure
        pos->tran.x = X;
        pos->tran.y = Y;
        pos->tran.z = 0.0;  // Assuming Z is not used, or set it as required

        rtapi_print("Converged: ThetaL = %f, ThetaR = %f\n", thetaL * 180 / PI, thetaR * 180 / PI);
        rtapi_print("Coordinates of convergence: X = %f, Y = %f\n", X, Y);

        return 0;
    }
    }
}

#include <math.h> // Ensure math.h is included for trigonometric functions

int kinematicsInverse(const EmcPose *pos, double *j, const KINEMATICS_INVERSE_FLAGS *iflags, KINEMATICS_FORWARD_FLAGS *fflags)
{
    double x_target = pos->tran.x;
    double y_target = pos->tran.y;

    // Calculate the distance from the center of the left drum to the target point
    double distance_left_drum_center_to_target = sqrt(pow(LEFT_DRUM_X - x_target, 2) + pow(LEFT_DRUM_Y - y_target, 2));

    // Calculate the distance from the center of the right drum to the target point
    double distance_right_drum_center_to_target = sqrt(pow(RIGHT_DRUM_X - x_target, 2) + pow(RIGHT_DRUM_Y - y_target, 2));

    // Calculate the length of the tangent from each drum to the target point
    double left_tangent_length_to_target = sqrt(pow(distance_left_drum_center_to_target, 2) - pow(DRUM_DIAMETER / 2, 2));
    double right_tangent_length_to_target = sqrt(pow(distance_right_drum_center_to_target, 2) - pow(DRUM_DIAMETER / 2, 2));

    // Calculate theta1 and theta2 for the left drum
    double theta1_left = atan(x_target / y_target); // Corrected sign
    double theta2_left = atan((DRUM_DIAMETER / 2) / left_tangent_length_to_target);
    double theta_left = theta1_left + theta2_left;

    // Calculate theta1 and theta2 for the right drum
    double theta1_right = atan((RIGHT_DRUM_X - x_target) / (y_target - RIGHT_DRUM_Y)); // Corrected sign
    double theta2_right = atan((DRUM_DIAMETER / 2) / right_tangent_length_to_target);
    double theta_right = theta1_right + theta2_right;


    // Calculate the arc length for each drum
    double left_arc_length = theta_left * (DRUM_DIAMETER / 2);
    double right_arc_length = theta_right * (DRUM_DIAMETER / 2);

    // Calculate the total cable length to target
    double left_cable_length_to_target = left_tangent_length_to_target + left_arc_length;
    double right_cable_length_to_target = right_tangent_length_to_target + right_arc_length;

    // Calculate the change in cable length from home
    double left_cable_length_change = LEFT_CABLE_HOME_LENGTH - left_cable_length_to_target;
    double right_cable_length_change = RIGHT_CABLE_HOME_LENGTH - right_cable_length_to_target;

    // Set the joint values to the change in cable lengths
    j[0] = left_cable_length_change;
    j[1] = right_cable_length_change;
    rtapi_print_msg(
        RTAPI_MSG_ERR,
        "kinematicsInverse joints: %d, %d, %d, %d\n",
        distance_left_drum_center_to_target,
	left_tangent_length_to_target,
	left_arc_length,
        j[0]
    );

    return 0;
}
